# 7 오류처리

* 코드 기반 대부분이 오류처리코드에 의해 좌우
 - 코드가 오류만 처리한다는 의미가 아닌, 오류처리를 잘해야 섞이지 않고 프로그램 논리를 이해하기 쉽다는 뜻.

## 오류코드보다 예외를 사용하라

`sendShutDown()`을 하는 것이 목표.,

* 오류 코드를 반환하는 방법의 예 (예전에는 예외를 지원하지 않는 언어가 있어 이런식으로 했음)

```java

//130쪽 (옛책 160)
public class DeviceController {
...
 public void sendShutDown() {
 	DeviceHandle handle = getHandle(DEV1);
    
  	//디바이스 상태를 점검한다.
   	if (handle != DeviceHandle.Invalid) {
	}
 }
}
```
- 함수를 호출한 즉시 오류를 확인해야하기 떄문에 호출자 코드가 복잡해짐.

* 예외를 던지는 것이 더 좋다.
- 논리가 오류처리 코드와 섞이지 않아서 호출자 코드가 깔금해짐

```
//131쪽
```

- 디바이스를 종료하는 알고리즘과 오류를 처리하는 알고리즘을 분리해, 각 개념을 독립적으로 살펴보고 이해가능하게 됨.

## try-catch-finally문 부터 작성하라

* try블록에서 무슨일이 생기든지 호출자가 기대하는 상태를 정의하기 쉬워짐.
* try블록 일종의 트랜잭션
* 강제로 예외를 일으키는 테스트케이스를 작성한 후 테스트를 통과하게 코드를 작성하는 방법 권장.
* try블록의 트랜잭션 범위 부터 구현하게 되므로 트랜잭션 본질을 유지하기 쉽다. 

## 미확인 (unchecked) 예외를 사용하라 

대규모 시스템에서 호출이 일어나는 방식

- 최상위 함수가 아래함수를 호출, 아래함수는  그 아래함수를 호출
- 단계를 내려갈 수록 호출하는 함수 수는 늘어남.

최하위 함수를 변경해 새로운 오류를 던진다?

- 확인된 오류를 던진다면 함수는 선언부에 throw절을 추가해야함.
- 그러면 수정한 함수를 호출하는 모든 함수가 catch블록에서 새로운 예외를 처리하거나 선언부에 throw절을 추가해야함.
==> 결과적으로 연쇄적 수정이 일어남...
==> throw 경로에 위치하는 모든 함수가 최하위 함수에서 던지는 예외를 알아야 하므로 캡슐화가 깨짐.

결론: 확인된 예외가 캡슐화를 깨버린다.
아주 중요한 라이브러리라면 모든 예외를 잡아야 하지만, 일반적인경우
모든 예외를 열거할 필요 없다. (비용의 문제)

## 예외에 의미를 제공하라

* 자바는 모든 예외에 호출스택을 제공하기는 하지만 실제 코드 의도 파악에는 부족
*오류메시지에 정보를 담아 예외와 함께 던진다.
  - 실패한 연산 이름과 실패유형도 언급
 - 애플리케이션에서 로깅기능을 사용한다면  catch블록에서 오류를 기록하도록 충분한 정보를 넘기기

## 호출자를 고려해 예외 클래스를 정의하라

오류를 분류하는 방법

* 오류가 발생한 위치 (발생한 컴포넌트로 분류)
* 오류의 유형으로 분류 (디바이스 실패, 네트워크 실패, 프로그래밍 오류.)

가장중요한 것은 오류를 잡는 방법임!

(예제코드 보기)

## 정상 흐름을 정의하라

(예제코드 보기)
### SPECIAL CASE PATTERN (FLOWER)

* 클래스를 만들거나 객체를 조작해 특수 사례를 처리하는 방식.
* 클래스나 객체가 예외적인 상황을 캡슐화해서 처리하므로, 클라이언트 코드가 예외적인 상황을 처리할 필요 없어짐.

## null을 반환하지 마라

* null을 반환해서 null 확인을 계속하는 것은 위험, 어디선가 확인을 빼먹으면 망!
* null을 반환하고 싶으면 예외를 던지거나 특수사례객체를 반환할 것!
* 코드의 예에서는 null보다는 빈 리스트를 반환

## null을 전달하지 마라

* null을 반환하는 것보다 더 나쁜 것은 null을 전달하는 방식
* 정상적인 인수로 null을 기대하는 API가 아니라면 메소드로 null을 전달하는 코드는 최대한 피하기.
* invalid Args Exception이나 assert로 판단하는 방법이 있긴하지만, 애초에 인수로 null이 넘어오면 문제가 있는 것 

## 결론

* 깨끗한 코드는 읽기도 좋아야 하지만 안정성도 높아야 함.
* 오류 처리를 프로그램 논리와 분리하면 깨끗하고 튼튼해서, 독립적인 추론이 가능해지며,
코드 유지보수성도 크게 높아짐.