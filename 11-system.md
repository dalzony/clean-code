# system

## 도시를 세운다면

* 모든 세세한 사항을 혼자 직접 관리하는 것은 불가능
  - 이미 세워진 도시라도 한사람의 힘으로는 무리
* 도시가 잘 돌아가는 이유 : 수도관리,전력관리,교통관리..등 각 분야를 관리하는 '팀'이 있기 때문.
* 큰 그림을 잘 그리는 사람도/ 작은일에 직중하는 사람도 있음

* => 적절한 추상화와 모듈화 때문
  - 큰 그림을 이해하지 못할지라도 개인과 개인이 관리하는 구성요소는 효율적으로 돌아감
* 소프트웨어 팀도 도시처럼 구성하지만 낮은 추상화 수준에서 관심사를 분리하기 어려움.
  - 시스템 수준에서 깨끗함을 유지하는 방법을 살펴본다.

## 시스템 제작과 시스템 사용을 분리하라

* 제작(construction)과 사용(use)는 아주 다르다.

> 소프트웨어 시스템은 (애플리케이션 객체를 제작하고 의존성을 서로 '연결'하는)
> 준비과정과 (준비 과정 이후에 이어지는) 런타임 로직을 분리해야한다.

### 관심사 분리

* 가장 중요한 설계 기법
* 모든 애플리케이션이 풀어야 할 관심사 : 시작단계
* 대부분 앱은 시작단계라는 관심사를 분리하지 않음, 준비과정과 런타임 로직이 뒤섞인 주먹구구식이 대부분

```
//주먹구구식 예
public Service getService() {
  if (service == null)
    service = new MyServiceImpl(...); //모든 상황에 적합한 기본 값일까?
  return service;	 
}
```

* 위: 초기화 지연 (Lazy Init) 또는 계산 지연 (Lazy Evaluation) 기법
* 장점
  - 실제 필요할 때까지 객체 생성하지 않으므로 불필요한 부하가 걸리지 않음 (애플리케이션을 시작하는 시간이 그만큼 빨라짐)
  - 어떤 경우라도 null포인터를 반환하지 않음
* 잘못된 점 
  - getService메서드가 MyServiceImpl과 (위에선 생략한) 생성자 인수에 명시적으로 의존
  - 런타임로직에서 MyServiceImpl 객체를 전혀 사용하지 않더라도 의존성을 해결하지 않으면 컴파일이 안됨
  - 테스트 문제 : MyServiceImpl이 무거운 객체면, 단위테스트에서 getService 메서드 호출전에, 적절한 테스트 전용객체를 service필드에 할당해야함.
  - 책임이 둘이 됨 : service가 null일때와 아닐 때와 같이모든 경로의 테스트를 해야함 ==> 단일 책임 원칙을 깸 (한메소드는 한가지 일만)
  - MyServiceImpl이 모든 상황에 적합한 객체인지 모른다는 사실이 가장 큰 우려. (주석)

* 초기화 지연방법을 한번정도 쓰는것은 문제가 안되지만, 많은 앱들이 이 설정을 수시로 사용하기 때문에, 앱 전체에 흩어져 있는 것이 문제
* 체계적이고 탄탄한 시스템을 위해서는 모듈성을 깨면안됨.
* 설정논리는 일반실행논리와 분리되어야함.

### Main 분리


### 팩토리

### 의존성 주입

## 확장

### 횡단 관심사

## 자바 프록시

## 순수 자바 AOP프레임 워크

## AspectJ관점

## 테스트 주도 시스템 아키텍처 구축

## 의사결정을 최적화 하라

## 명백한 기치가 있을 때 표준을 현명하게 사용하라

## 시스템은 도메인 특화언어가 필요하다

## 결론

