# 단위 테스트

## TDD 법칙 세가지
* 첫째 법칙: 실패하는 단위 테스트를 작성할 때까지 실제 코드를 작성하지 않는다.
* 둘째 법칙: 컴파일은 실패하지 않으면서 실행이 실패하는 정도로만 단위 테스트를 작성한다.
* 셋째 법칙: 현재 실패하는 테스트를 통과할 정도로만 실제 코드를 작성한다.

=> 위의 방법을 따르면 실제 코드를 전부 테스트하는 테스트 케이스가 나오지만, 실제 코드와 맞먹을 정도로 방대한 테스트 코드는 심각한 관리 문제를 유발한다.

## 깨끗한 테스트 코드 유지하기
### 지저분한 테스트 코드의 문제
* 실제 코드가 진화하면 테스트 코드도 변해야 하지만, 테스트 코드가 복잡하면 실제 코드를 짜는 시간보다 테스트 케이스를 추가하는 시간이 더 걸리게 된다.
* 실제 코드를 변경해 기존 테스트 케이스가 실패하기 시작하면, 지저분한 코드로 인해 실패하는 테스트 케이스를 점점 더 통과시키기가 어려워진다. => 테스트 코드는 계속해서 늘어나는 부담이 되어 버린다.

### 테스트 슈트가 없다면
* 개발자는 자신이 수정한 코드가 제대로 도는지 확인할 방법이 없다 => 개발자는 변경을 주저하게 된다. 

결론은 테스트 코드는 깨끗이 짜자.
테스트 코드는 실제 코드 못지 않게 중요하다.
실제 코드 못지 않게 깨끗하게 짜야한다.

### 테스트는 유연성, 유지보수성, 재사용성을 제공한다
* 코드에 유연성, 유지보수성, 재사용성을 제공하는 버팀목이 바로 단위테스트이다.
* 테스트 케이스가 있으면 변경이 쉬워진다.

## 깨끗한 테스트 코드
* 깨끗한 테스트 코드를 만드려면 '가독성'이 중요하다.
* 목록[9-1], [9-2] 참고

### 도메인에 특화된 테스트 언어
* 목록[9-2]는 도메인에 특화된 언어로 테스트 코드를 구현하는 기법을 보여준다.
* API 위에다가 함수와 유틸리티를 구현해 사용함으로서 테스트 코드를 짜기도 읽기도 쉽게 했다.
* 테스트를 구현하는 당사자와 나중에 테스트를 읽어볼 독자를 도와주는 테스트 언어다.

### 이중 표준
* 테스트 API 코드에 적용하는 표준은 실제 적용하는 표준과 다르다.
* 단순하고, 간결하고, 표현력이 풍부해야 하지만, 실제 코드만큼 효율적일 필요는 없다.
* 목록[9-3] 참고 -> 읽기 어렵다
* 목록[9-4] 참고 -> 가독성을 높였다
* 목록[9-5] 참고 -> 테스트 코드를 이해하기 쉽다

## 테스트 당 assert 하나
* assert문이 단 하나인 함수는 결론이 하나라서 코드를 이해하기 쉽고 빠르다.
* 목록[9-2] -> 목록[9-7]
* assert문 갯수는 최대한 줄여야 좋다.

### 테스트 당 개념 하나
* 테스트 함수마다 한 개념만 테스트 하라.
* 목록[9-8]은 바람직하지 못한 테스트 함수이다.
* 목록[9-8]은 한 테스트 함수에서 여러 개념을 테스트한다는 사실이 문제다.

가장 좋은 규칙
=> 개념 당 assert 문 수를 최소로 줄여라
=> 테스트 함수 하나는 개념 하나만 테스트하라

## F.I.R.S.T

깨끗한 테스트는 다음 다섯가지 규칙을 따른다.

* 빠르게(Fast): 테스트는 빨리 돌아야 한다. 테스트가 느리면 자주 돌릴 엄두를 못낸다.
* 독립적으로(Independent): 각 테스트는 서로 의존하면 안된다. 각 테스트는 독립적으로 그리고 어떤 순서로 실행해도 괜찮아야 한다.
* 반복가능하게(Repeatable): 테스트는 어떤 환경에서도 반복 가능해야 한다. 테스트가 돌아가지 않는 환경이 하나라도 있다면 테스트가 실패한 이유를 둘러댈 변명이 생긴다.
* 자가검증하는(Self-Validating): 테스트는 bool 값으로 결과를 내야한다. 성공 아니면 실패다.
* 적시에(Timely): 테스트는 적시에 작성해야 한다. 단위 테스트는 테스트하려는 실제 코드를 구현하기 직전에 구현한다.

## 결론
* 테스트 코드는 실제 코드만큼이나 프로젝트 건강에 중요하다.
* 테스트 코드는 지속적으로 개끗하게 관리하자.
* 테스트 API를 구현해 도메인 특화 언어를 만들자.
